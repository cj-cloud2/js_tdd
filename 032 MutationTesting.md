
-----

## An Introduction to Mutation Testing

### What is Mutation Testing?

Mutation testing is a technique used to evaluate the quality of your existing test suite by making small, automatic changes (called **mutants**) to your source code and then running your tests against those modified versions. If a test fails (the mutant is **killed**), your test suite is effective. If all tests still pass (the mutant **survives**), it suggests a gap or weakness in your tests. It doesn't tell you if your tests are *effective* at catching bugs.

The process works like this:

1.  **Mutate:** The framework makes one small, non-obvious change to your source code. This new, "faulty" version is called a **mutant**.
      * `a + b` becomes `a - b`
      * `a > b` becomes `a <= b`
      * `"Hello"` becomes `""`
2.  **Test:** It runs your entire test suite against this single mutant.
3.  **Analyze:**
      * **âœ… Mutant Killed:** One of your tests failed. This is **good\!** It means your test suite successfully "detected" the bug.
      * **ðŸ’€ Mutant Survived:** All of your tests still passed, even with the bug. This is **bad\!** It reveals a weak test that isn't properly checking the logic.
	  
4.  **Repeat:** The framework does this hundreds or thousands of times, creating a comprehensive report of your test suite's "bug-catching" ability.

-----

### Example: The Weak Calculator

Let's illustrate this with the exact example you provided.

#### 1\. The Source Code (SUT)

Here is our simple `calculator.js`:

```javascript
// calculator.js
class Calculator {
  sum(a, b) {
    return a + b;
  }
  subtract(a, b) {
    return a - b;
  }
  multiply(a, b) {
    return a * b;
  }
  divide(a, b) {
    return a / b;
  }
}
module.exports = Calculator;
```

#### 2\. The Test Suite

Here is our `calculator.test.js`. Note the **weak test for `sum()`**:

```javascript
// calculator.test.js
const Calculator = require('./calculator');
const calc = new Calculator();

// WEAK TEST: This mutant will SURVIVE
test('sum() should add two numbers', () => {
  expect(calc.sum(4, 0)).toBe(4);
});

// STRONG TEST: This mutant will be KILLED
test('subtract() should subtract two numbers', () => {
  expect(calc.subtract(10, 2)).toBe(8);
});

// STRONG TEST: This mutant will be KILLED
test('multiply() should multiply two numbers', () => {
  expect(calc.multiply(3, 4)).toBe(12);
});

// STRONG TEST: This mutant will be KILLED
test('divide() should divide two numbers', () => {
  expect(calc.divide(10, 5)).toBe(2);
});
```

#### 3\. Stryker Runs the Mutants

Stryker Mutator will now create mutants for each function and run our tests.

**Mutant 1: `sum()`**

  * **Mutation:** `return a + b;` is changed to `return a - b;`
  * **Test Run:** The weak test `expect(calc.sum(4, 0)).toBe(4)` is executed.
  * **Result:** The mutated code calculates `4 - 0`, which is `4`. The test `expect(4).toBe(4)` still **PASSES**.
  * **Outcome: ðŸ’€ Mutant Survived** (We found a weak test\!)

**Mutant 2: `subtract()`**

  * **Mutation:** `return a - b;` is changed to `return a + b;`
  * **Test Run:** The strong test `expect(calc.subtract(10, 2)).toBe(8)` is executed.
  * **Result:** The mutated code calculates `10 + 2`, which is `12`. The test `expect(12).toBe(8)` **FAILS**.
  * **Outcome: âœ… Mutant Killed**

**Mutant 3: `multiply()`**

  * **Mutation:** `return a * b;` is changed to `return a / b;`
  * **Test Run:** The strong test `expect(calc.multiply(3, 4)).toBe(12)` is executed.
  * **Result:** The mutated code calculates `3 / 4`, which is `0.75`. The test `expect(0.75).toBe(12)` **FAILS**.
  * **Outcome: âœ… Mutant Killed**

**Mutant 4: `divide()`**

  * **Mutation:** `return a / b;` is changed to `return a * b;`
  * **Test Run:** The strong test `expect(calc.divide(10, 5)).toBe(2)` is executed.
  * **Result:** The mutated code calculates `10 * 5`, which is `50`. The test `expect(50).toBe(2)` **FAILS**.
  * **Outcome: âœ… Mutant Killed**

-----

### ðŸŒŸ Stryker Mutator

The most prominent mutation testing framework in the JavaScript ecosystem is **Stryker Mutator**.


* **Key Framework:** Stryker Mutator is widely recognized as the primary and most actively maintained open-source framework for mutation testing in JavaScript and TypeScript.
* **Functionality:** It automates the process of generating numerous mutants (e.g., changing `+` to `-`, `<` to `<=`, or `true` to `false`) and executing your test suite against each one.
* **Compatibility:** Stryker is test runner-agnostic and supports various popular tools, including:
    * Jest
    * Mocha
    * Jasmine
    * Karma
* **Ecosystem Support:** It also comes with plugins for tools like **Webpack**, **Babel**, and provides native support for **TypeScript**.
Here is a document explaining Mutation Testing, the score generated by Stryker, and the requested calculator example.


### Stryker Mutator's Value vs. Theoretical Score

The "value" generated by Stryker is its **Mutation Score**, but it's more nuanced than the simple, theoretical definition.

#### Theoretical Mutation Score

The academic or "theoretical" definition of a mutation score is very simple:

> **Theoretical Score** = (Killed Mutants / Total Mutants) \* 100

In our simple example: 3 Killed / 4 Total = **75%**

#### Stryker Mutator's "Mutation Score"

Stryker's score is more practical and actionable for developers. It recognizes that not all mutants are created equal. Stryker categorizes mutants into several "fates":

  * **Killed:** A test failed. (Good)
  * **Survived:** All tests passed. (Bad)
  * **No Coverage:** No test ran this code, so the mutant couldn't be tested. (Bad)
  * **Timeout:** The mutation caused an infinite loop, and the test runner timed out. (Good, treated as "Killed")
  * **Error:** The mutation resulted in invalid code (e.g., a syntax error). (Ignored)

Stryker's score is calculated based on the mutants that *mattered*. It filters out the "Error" mutants that were impossible to test.

> **Stryker's Score** = (Killed + Timeout) / (Killed + Timeout + Survived + No Coverage) \* 100

**The key difference** is that the theoretical score is a simple ratio, while **Stryker's score is a more robust, practical metric**. It distinguishes *why* a mutant wasn't killed, separating "Survived" (weak tests) from "No Coverage" (missing tests), giving you a much clearer path to improving your test suite. The "value" it provides is a score based on *actionable* results, not just all *possible* mutations.
### Why Mutation Testing?

Traditional code coverage metrics (like line or branch coverage) only tell you **what** code is executed by your tests, not **how well** it is tested. Mutation testing helps you:

* **Verify Test Effectiveness:** It confirms that your assertions are strong enough to detect faults if the underlying logic were slightly altered.
* **Identify Gaps:** It points out code paths where tests might be executing the code but lack meaningful assertions to guarantee correct behavior.

